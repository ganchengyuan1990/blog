[{"title":"vuex初探","date":"2017-01-17T02:27:29.000Z","path":"2017/01/17/vuex初探/","text":"Vuex的作用是什么Vuex主要用来进行状态管理，我的理解就是当你的VUE项目大到一定程度以后，需要一个帮手来帮助你进行组件管理，尤其是多层次的组件进行信息交互时，如果没有这样一个工具，就得维护公共变量或者一层一层传递参数，这个过程是非常令人不愉悦的。 引入12345import Vuex from 'vuex';import * as actions from './actions'; //改变状态都得通过这里的方法import * as getters from './getters'; //获取状态值的方法 store对象这个对象就是Vuex创建的实例对象，是重点需要学习的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const store = &#123; //state对象维护具体状态值 state: &#123; isInitData: true, //首次刷新页面 &#125;, /** * vuex 2.0 action should be await Vuex规定每个状态值的改变最后都要通过actions函数来操作，并且规定必须是异步，因此调取接口的操作应该都在这里 */ actions: &#123; fetchSearchDataAction: (&#123; commit, dispatch &#125;, options) =&gt; &#123; commit('SET_TOP_LOADING', &#123; type: true &#125;) &#125;, &#125;, /** * even vuex 2.0 mutations should be async actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。 */ mutations: &#123; [types.COMBINE_DETAIL_LIST](state, res) &#123; let cloneMerchandiseList = []; state.merchandiseList.forEach(item =&gt; &#123; cloneMerchandiseList.push(Object.assign(&#123;&#125;, item, res[item.sm_seq])); &#125;) //combine 合并基础对象和详细属性,重现渲染列表 state.merchandiseList = cloneMerchandiseList; &#125; &#125;, getters: &#123; listDownType: (state) =&gt; &#123; let type = '' state.selectListData.filter(item =&gt; &#123; if(item.isSelect)&#123; type = item.sortType &#125; &#125;) return type &#125; &#125;&#125; 注：同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。","tags":[]},{"title":"javascript闭包个人理解","date":"2017-01-17T00:56:37.000Z","path":"2017/01/17/javascript闭包个人理解/","text":"个人理解，闭包的目的就是为了从外部读取内部函数的局部参数而设置的桥梁方法。 12345678910111213141516171819202122232425function closure() &#123; var n = 1; nAdd=function()&#123;n+=1; &#125; function inner()&#123; alert(n) &#125; return inner;&#125;var result = closure();result();nAdd();result(); // 1000var name = \"The Window\"; var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;;alert(object.getNameFunc()());","tags":[]},{"title":"Vue个人网站搭建","date":"2017-01-16T09:13:04.353Z","path":"2017/01/16/第一篇/","text":"自学Vue也有将近一个月了，想做个简单的小作品，正好这段时间自己的阿里云服务器闲置着，而且个人域名一直缺一个主页面，自然就想到做一个小项目来改装一下门庭。 ###手机预览(website) 废话不多说，上预览，http://www.jasongan.cn 安装install dependenciesnpm install serve with hot reload at localhost:8080npm run dev build for production with minificationnpm run build ``` 技术栈 vue-wechat是主要在利用Vue.js。 此demo在实现上使用了以下技术 “vue”: “^1.0.21”, 考虑到Vue2.0组件还不够丰富，因此就还是想用1.0+的版本。 “vue-resource”: “^1.0.0”, 要获取数据就要调API，在requireJs架构中使用Jquery即可，但是毕竟Jquery与Vue的思想是背道而驰的，因此选择使用”vue-resource”这套组件，她提供了非常友好而已用的API，来帮助我们非常快速简单地进行数据请求。 “mint-ui”: “^1.0.2” UI组件我选择大名鼎鼎的由饿了么前端团队出品的Mint-ui，这套组件文档丰富，更新快（现已完全支持Vue2.0+），能够满足80%左右前端UI的需求。 “vue-echarts”: “^1.0.0”, Echarts我原来就很喜欢了，百度的产品，有非常丰富的图表类型可供选择。原本使用的是Vue-chartjs，但是最后发现”vue-echarts”对”vue-resource”的支持更好（选择组件的过程中发现，一个好的组件，一定要做到对常用其他组件的支持，否则就失去存在意思，会被淘汰）。 vue-animated-list “vuex”: “^1.0.0-rc.2”, 这个组件的意义在于清晰地状态管理，结合Chrome上的调试工具，玩法很多。 vue-router fastclick 注：在这边要提醒一下，一定要保持各组件之间的版本对应，必须时在npm安装时可以简单地在后面加上@X（版本号）来安装对应版本。","tags":[]},{"title":"搭好了我的博客","date":"2017-01-16T08:12:12.622Z","path":"2017/01/16/hello-world/","text":"最近这两天工作并不忙，因此有很多时间自学，今天也是用Hexo和Github搭建了这个个人的技术博客，希望以后可以多写点东西，多长进！列一下这段时间准备研究的东西 Node.js对于一个前前端的全栈工程师来说，Node.js是非常好的语言，并且学习社区非常完善，资料健全，很有意思。 Vue.jsVue是一个很容易上手的框架，单页面应用也是非常好的一个前端网页思路，有效地减少白屏带来的视觉问题。这两天在做搭个人网站的时候用上了Vue，打包完也有2M左右，组件太丰富，选择是一个问题。 MongoDb123$(document).ready(function () &#123; alert('hello world');&#125;); 数据库的选择，效率不错，API也很好使用。","tags":[]}]