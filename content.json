[{"title":"html render & paint（重排和重绘）","date":"2017-01-18T03:05:38.000Z","path":"2017/01/18/html-render-paint/","text":"首先，先吐槽一下weex学习社区的内容真的非常不全面，自学很难，优点是调试相对简单，暂时放一放，以后有空再看看。 接下来进入正题，讲一讲昨天刚复习的有关浏览器页面渲染的知识点。 ##repaint、reflow/relayout、restyle 这四个概念分别代表什么？先来看一张图，了解一下浏览器页面的渲染过程 这里要注意的是：要生成Dom Tree和Css Tree以后才会生成render tree，然后进行绘制(paint)。1. 首先，浏览器解析HTML源码构建DOM树，在DOM树中，每个HTML标签都有对应的节点，并且在介于两个标签中间的文字块也对应一个text节点。DOM树的根节点是documentElement，也就是标签；2. 然后，浏览器对CSS代码进行解析，一些当前浏览器不能识别的CSS hack写法（如-moz-/-webkit等前缀，以及IE下的/_等）将会被忽略。CSS样式的优先级如下：最低的是浏览器的默认样式，然后是通过、import引入的外部样式和行内样式，最高级的是直接写在标签的style属性中的样式；3. 随后将进入非常有趣的环节-构建渲染树。渲染树跟DOM树结构相似但并不完全匹配。渲染树会识别样式，所以如果通过设置display:none隐藏的标签是不会被渲染树引入的。同样的规则适用于标签以及其包含的所有内容。另外，在渲染树中可能存在多个渲染节点（渲染树中的节点称为渲染节点）映射为一个DOM标签，例如，多行文字的标签中的每一行文字都会被视为一个单独的渲染节点。渲染树的一个节点也称为frame-结构体，或者盒子-box（与CSS盒子类似）。每个渲染节点都具有CSS盒子的属性，如width、height、border、margin等；4. 最后，等待渲染树构建完毕后，浏览器便开始将渲染节点一一绘制-paint到屏幕上。。OK，接下来看一个例子1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;title&gt;Beautiful page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; Once upon a time there was a looong paragraph... &lt;/p&gt; &lt;div style=\"display: none\"&gt; Secret message &lt;/div&gt; &lt;div&gt;&lt;img src=\"...\" /&gt;&lt;/div&gt; ... &lt;/body&gt;&lt;/html&gt;这个html对应的DOM结构如下：1234567891011121314documentElement (html) head title body p [text node] div [text node] div img ...由于渲染树会忽略head内容和隐藏的节点，并且会将中的多行文字按行数映射为单独的渲染节点，故构建完成的渲染树结构如下：123456789101112root (RenderView) body p line 1 line 2 line 3 ... div img ...## 重绘-repaint和回流（重排）-reflow同一时间内至少存在一个页面初始化layout行为和一个绘制行为（除非你的页面是空白页-blank）。在此之后，改变任何影响构造渲染树的行为都会触发以下一种或者多种动作：1. 渲染树的部分或者全部将需要重新构造并且渲染节点的大小需要重新计算。这个过程叫做回流-reflow，或者layout，或者layouting（靠，能不能愉快的翻译了，是不是还来个过去式啊?!），或者relayout（这词是原文作者杜撰的，为了标题中多个“R”）。浏览器中至少存在一个reflow行为-即页面的初始化layout；2. 屏幕的部分区域需要进行更新，要么是因为节点的几何结构改变，要么是因为格式改变，如背景色的变化。屏幕的更新行为称作重绘-repaint，或者redraw。## 如何减少重绘和回流减少因为重绘和回流引起的糟糕用户体验的本质是尽量减少重绘和回流，减少样式信息的set行为。可以通过以下几点来优化：1. 不要逐个修改多个样式。对于静态样式来说，最明智和易维护的代码是通过改变classname来控制样式；而对于动态样式来说，通过一次修改节点的cssText来代替样式的逐个改变。2. “离线”处理多个DOM操作。“离线”的意思是将需要进行的DOM操作脱离DOM树，比如： 通过documentFragment集中处理临时操作； 将需要更新的节点克隆，在克隆节点上进行更新操作，然后把原始节点替换为克隆节点；* 先通过设置display:none将节点隐藏（此时出发一次回流和重绘），然后对隐藏的节点进行100个操作（这些操作都会单独触发回流和重绘），完毕后将节点的display改回原值（此时再次触发一次回流和重绘）。通过这种方法，将100次回流和重绘缩减为2次，大大减少了消耗3. 不要过多进行重复的样式计算操作。如果你需要重复利用一个静态样式值，可以只计算一次，用一个局部变量储存，然后利用这个局部变量进行相关操作。4. 总之，当你在打算改变样式时，首先考虑一下渲染树的机制，并且评估一下你的操作会引发多少刷新渲染树的行为。例如，我们知道一个绝对定位的节点是会脱离文档流，所以当对此节点应用动画时不会对其他节点产生很大影响，当绝对定位的节点置于其他节点上层时，其他节点只会触发重绘，而不会触发回流。## restyle到底是什么？仔细的朋友会发现，到现在我们也没具体说restyle的情况，restyle指的是没有几何结构改变的渲染树变化。也就是说restyle和reflow是一个层次的概念，完成以后都会引发repaint! 总结一下重新计算渲染树的行为被Mozilla称为回流-reflow，被其他浏览器称为layout；将重新计算后的渲染树更新到屏幕的行为叫做重绘-repaint，或者redraw（in IE/DynaTrace）；","tags":[]},{"title":"vuex初探","date":"2017-01-17T02:27:29.000Z","path":"2017/01/17/vuex初探/","text":"Vuex的作用是什么Vuex主要用来进行状态管理，我的理解就是当你的VUE项目大到一定程度以后，需要一个帮手来帮助你进行组件管理，尤其是多层次的组件进行信息交互时，如果没有这样一个工具，就得维护公共变量或者一层一层传递参数，这个过程是非常令人不愉悦的。 引入12345import Vuex from 'vuex';import * as actions from './actions'; //改变状态都得通过这里的方法import * as getters from './getters'; //获取状态值的方法 store对象这个对象就是Vuex创建的实例对象，是重点需要学习的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const store = &#123; //state对象维护具体状态值 state: &#123; isInitData: true, //首次刷新页面 &#125;, /** * vuex 2.0 action should be await Vuex规定每个状态值的改变最后都要通过actions函数来操作，并且规定必须是异步，因此调取接口的操作应该都在这里 */ actions: &#123; fetchSearchDataAction: (&#123; commit, dispatch &#125;, options) =&gt; &#123; commit('SET_TOP_LOADING', &#123; type: true &#125;) &#125;, &#125;, /** * even vuex 2.0 mutations should be async actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。 */ mutations: &#123; [types.COMBINE_DETAIL_LIST](state, res) &#123; let cloneMerchandiseList = []; state.merchandiseList.forEach(item =&gt; &#123; cloneMerchandiseList.push(Object.assign(&#123;&#125;, item, res[item.sm_seq])); &#125;) //combine 合并基础对象和详细属性,重现渲染列表 state.merchandiseList = cloneMerchandiseList; &#125; &#125;, getters: &#123; listDownType: (state) =&gt; &#123; let type = '' state.selectListData.filter(item =&gt; &#123; if(item.isSelect)&#123; type = item.sortType &#125; &#125;) return type &#125; &#125;&#125; 注：同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。","tags":[]},{"title":"javascript闭包个人理解","date":"2017-01-17T00:56:37.000Z","path":"2017/01/17/javascript闭包个人理解/","text":"个人理解，闭包的目的就是为了从外部读取内部函数的局部参数而设置的桥梁方法。 12345678910111213141516171819202122232425function closure() &#123; var n = 1; nAdd=function()&#123;n+=1; &#125; function inner()&#123; alert(n) &#125; return inner;&#125;var result = closure();result();nAdd();result(); // 1000var name = \"The Window\"; var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;;alert(object.getNameFunc()());","tags":[]},{"title":"Vue个人网站搭建","date":"2017-01-16T09:13:04.353Z","path":"2017/01/16/第一篇/","text":"自学Vue也有将近一个月了，想做个简单的小作品，正好这段时间自己的阿里云服务器闲置着，而且个人域名一直缺一个主页面，自然就想到做一个小项目来改装一下门庭。 ###手机预览(website) 废话不多说，上预览，http://www.jasongan.cn 安装install dependenciesnpm install serve with hot reload at localhost:8080npm run dev build for production with minificationnpm run build ``` 技术栈 vue-wechat是主要在利用Vue.js。 此demo在实现上使用了以下技术 “vue”: “^1.0.21”, 考虑到Vue2.0组件还不够丰富，因此就还是想用1.0+的版本。 “vue-resource”: “^1.0.0”, 要获取数据就要调API，在requireJs架构中使用Jquery即可，但是毕竟Jquery与Vue的思想是背道而驰的，因此选择使用”vue-resource”这套组件，她提供了非常友好而已用的API，来帮助我们非常快速简单地进行数据请求。 “mint-ui”: “^1.0.2” UI组件我选择大名鼎鼎的由饿了么前端团队出品的Mint-ui，这套组件文档丰富，更新快（现已完全支持Vue2.0+），能够满足80%左右前端UI的需求。 “vue-echarts”: “^1.0.0”, Echarts我原来就很喜欢了，百度的产品，有非常丰富的图表类型可供选择。原本使用的是Vue-chartjs，但是最后发现”vue-echarts”对”vue-resource”的支持更好（选择组件的过程中发现，一个好的组件，一定要做到对常用其他组件的支持，否则就失去存在意思，会被淘汰）。 vue-animated-list “vuex”: “^1.0.0-rc.2”, 这个组件的意义在于清晰地状态管理，结合Chrome上的调试工具，玩法很多。 vue-router fastclick 注：在这边要提醒一下，一定要保持各组件之间的版本对应，必须时在npm安装时可以简单地在后面加上@X（版本号）来安装对应版本。","tags":[]},{"title":"搭好了我的博客","date":"2017-01-16T08:12:12.622Z","path":"2017/01/16/hello-world/","text":"最近这两天工作并不忙，因此有很多时间自学，今天也是用Hexo和Github搭建了这个个人的技术博客，希望以后可以多写点东西，多长进！列一下这段时间准备研究的东西 Node.js对于一个前前端的全栈工程师来说，Node.js是非常好的语言，并且学习社区非常完善，资料健全，很有意思。 Vue.jsVue是一个很容易上手的框架，单页面应用也是非常好的一个前端网页思路，有效地减少白屏带来的视觉问题。这两天在做搭个人网站的时候用上了Vue，打包完也有2M左右，组件太丰富，选择是一个问题。 MongoDb123$(document).ready(function () &#123; alert('hello world');&#125;); 数据库的选择，效率不错，API也很好使用。","tags":[]}]